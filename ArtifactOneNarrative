#ENHANCEMENT ONE:

The enhancement is categorized as an implementation that reflects my experience in development and design. Enhancements that involve development and design would highlight skills that are involved in architectural design, followed by implementation of the design. In this context, I picked up an artifact to enhance the delivery of its functional and nonfunctional requirements and then implement what the design could need for improvements.  

The artifact I chose was a **lab assignment in a full stack development course**, which I was currently taking at the time of writing this narrative. It is a simple quiz that runs off React and uses API routes to update and retrieve data from an external JSON file.  

There are a selection of multiple quizzes when the site renders, as it was gathered from the call of an `/api/quiz` route. When the user selects a topic, they proceed to answer all the questions, with each question's content changing when the user clicks the **Next** button, which increments the JSON’s index and reloads React elements. Once the quiz is finished, the website updates the JSON object with a **session start time**, **session end time**, and a **score number**, which is displayed on the webpage.  

On its own, the artifact shows my experience with developing a frontend and backend for a website.  

## Enhancement Description

My improvement for this artifact involves **adding a login page** for the user to insert their credentials (username and password) to gain access to the main page.  

- This implementation was done in the same `index.html` file, as the React framework was handling element manipulation through an **index handler JSX file** referenced on `index.html`.  
- The page calls an API route that checks if an authorized user is accessing the page. If there is no authorized user, it sends a **302 response** and creates elements that resemble a login page with two fields and a button inside a form.  
- Another route is accessed to check if the username and password are valid. This logic isn’t complete and will be expanded with the **database enhancement**, as the requests will be compared to data from Firebase/MongoDB.  
- Lastly, there is a **logout route** that clears the active user data, allowing the route to be called again and sending the user back to the login page.  

The full stack website’s design now has a **state machine** that is only accessible if there is a user recognized in the backend.  

### Quality of Life Features

There are also new features improving the display of results:  

- **Total time** taken to complete the quiz is displayed instead of the start and end times.  
- **Score** is displayed out of the number of questions in the test, rather than just the raw score.  

## Challenges and Reflections

This artifact mostly showcased my approach to **expanding a design** from a simpler version, building an architecture, and formulating a plan that involves a database for the app.  

I am not done enhancing this project, as there are plenty of features dependent on **database integration**, so my procedure was limited.  

Another challenge I encountered involved scaling the backend. I intended the enhancement to involve the backend doing more heavy lifting, which was a feature on the backlog I rolled back on upon realizing the project has **two backends**:  

- One tested locally using **Mock Service Worker (MSW)**  
- Another powered by **Express API** for a deployed server  

Any change in the backend must be mirrored in both MSW and `server.js`. I also learned that **minimizing the number of server roundtrips** alleviates latency experienced by the website.  

## Conclusion

Overall, I met the planned outcomes with this enhancement, as I demonstrated my idea for **expanding the architecture** for my app by implementing features that would **scale with future enhancements**, including a database-centric enhancement.

#ENHANCEMENT THREE (uses same artifact)

Enhancement three is a continuation of enhancement one, featuring the same artifact, being the Qzicl app I developed from my full stack course.

The enhancement revolved around the practice of implementing an advanced architecture that improves features and adds more by expanding the functionality, whereas this new enhancement involves the practice of implementing and manipulating a database.

In my previous enhancement, I added a login feature that would present itself as the landing page’s first screen if the GET “/api/user” route does not recognize an active user. I also implemented a logout button that would log the user out by setting the current user of the backend back to null, so the user returns to the login page, that is returned as a react object. 

The login page could let any user in: As long as the user input text in both of the fields of the form and clicked the submit button, they could enter the homepage with all the quizzes and tests to take.

This was intended, as I planned, to use the logic handled by logins' respective post route in a separate .js file that connects the app to Firebase. Firebase is a cloud web hosting service that gives developers tools for app deployment such as their own authentication and their own databases, with the databases being called Firestore.

## Enhancement Description

Additional to implementation of Firebase to the full stack implementation, I added a new registration feature to the front end, with its own api route and logic that would create new documents inside the collections of the relational database.

The registration is a popup that shows itself once a button is clicked and hides itself when the close button is pressed. It is an overlay with a higher z index than the previously implemented elements, so it shows itself over the other content. 

The registration accepts three fields:

-A new username
-A new password that gets encrypted using a SHA-256 hashmap
-A confirm password field that compares itself to the new password in the frontend

## Quality of Life Features

For security reasons, I decided to implement a an encryption object to the backend, which uses the SHA-256 hash map to create a code that will be stored on the database, and not the string itself (vulnerable to data breaches).

```
async function hashPassword(password) {
  const encoder = new TextEncoder();
  const data = encoder.encode(password);

  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return [...new Uint8Array(hashBuffer)]
    .map(b => b.toString(16).padStart(2, "0"))
    .join("");
}
```

The registration also had to make sure that an instance of a document with the same username didn’t exist, to ensure there’s no duplicate usernames. This is solved by making a query that finds all the documents where the username matches the registration input.

```
const q = query(collectionRef,where("username", "==", dataToUpload.username));
const querySnapshot = await getDocs(q);
if (!querySnapshot.empty) {
    throw new Error("Username taken");
}
```
The inverse of this logic is applied for the login route, with its new functionality to check if the user added the right info, checking the username before checking the password. 

## Challenges and Reflections

I wanted to enhance the feature that updates the JSON object with the session score and session time of the user, so each user would have their own set of data, but I was facing issues with the lack of scalability that the architecture of the project had, considering that it was primarily meant to store data in the quizData.json folder, and the front end was more responsible for the logic and the payloads, not just the payloads.

If my application gave the backend (server.js) a bigger workload with more API calls such as getting the data tied to a selected topic, or updating the session time and score, then it would be easier to implement a time and session payload into the Firestore.

My app began to mostly rely on the backend now, as it abandoned mock service worker, because it doesn’t integrate with Firebase, and I found locally hosting with a backend port to be much easier.

## Conclusion

Even when I didn’t manage to get all the data I wanted into Firestore’s collection, I still demonstrated the ability to add and query data to create functional login and register features, even giving them security measures that involve hashing the passwords and comparing the encryptions, and querying passwords after querying usernames, with constructed shapes.

My application did not need to justify a call to remove a document, as it was out of scope. The crux of this enhancement narrative and the work attached to it is to demonstrate my connection of a database to a full stack application, and my capability to dynamically store different user input objects in said database. 
